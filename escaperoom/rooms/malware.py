"""Malware room logic: load JSONL process tree and find chains ending in curl/scp."""

from typing import Any


import json
from collections import deque


class ProcessTree:
    def __init__(self):
        self.processes = {}   # pid -> process data
        self.children = {}    # ppid -> list of child pids
        self.start_pid = None   # Will be detected from root process
        self.targets = ["curl", "scp"]

    def _load(self, jsonl_file: str):
        with open(jsonl_file, 'r') as f:
            for line in f:
                if not line.strip():
                    continue
                try:
                    proc = json.loads(line)
                    pid = proc.get("pid")
                    ppid = proc.get("ppid")
                    if pid is None:
                        continue
                    self.processes[pid] = proc
                    if ppid is not None:
                        self.children.setdefault(ppid, []).append(pid)
                    # Detect root process (ppid == 0 or None)
                    if ppid == 0 or ppid is None:
                        if self.start_pid is None:
                            self.start_pid = pid
                except json.JSONDecodeError:
                    continue
        
        # Fallback: if no root process found, use first pid
        if self.start_pid is None and self.processes:
            self.start_pid = min(self.processes.keys())

    def dfs_find_target(self, start_pid: int, targets):
        visited = set[Any]()

        def dfs(pid, path):
            if pid in visited:
                return None
            visited.add(pid)
            cmd = self.processes.get(pid, {}).get("cmd", "")
            if any(t in cmd for t in targets):
                return pid, path + [pid], cmd
            for child in self.children.get(pid, []):
                result = dfs(child, path + [pid])
                if result:
                    return result
            return None

        return dfs(start_pid, [])

    def bfs_find_target(self, start_pid: int, targets):
        visited = {start_pid}
        queue = deque[tuple[int, list[int]]]([(start_pid, [start_pid])])
        while queue:
            pid, path = queue.popleft()
            cmd = self.processes.get(pid, {}).get("cmd", "")
            if any(t in cmd for t in targets):
                return pid, path, cmd
            for child in self.children.get(pid, []):
                if child not in visited:
                    visited.add(child)
                    queue.append((child, path + [child]))
        return None
    
    def format_evidence(self, pid, path, cmd):
        path_str = "->".join(map(str, path))
        return [
            f"TOKEN[PID]={pid}",
            f"EVIDENCE[PID].PATH=[{path_str}]",
            f"EVIDENCE[PID].CMD=\"{cmd}\""
        ]


        
    def inspect(self, filepath: str, game_state):
        """Inspect the process tree and find malicious processes."""
        output = ["[Room Malware] Analyzing process tree..."]
        
        self._load(filepath)
        
        if self.start_pid is None:
            output.append("Error: No root process found in process tree.")
            return output
        
        output.append(f"Starting from root PID: {self.start_pid}")
        
        # DFS
        dfs_result = self.dfs_find_target(self.start_pid, self.targets)
        if dfs_result:
            pid, path, cmd = dfs_result
            evidence = self.format_evidence(pid, path, cmd)
            output.extend(evidence)
            # Update game state
            game_state.tokens["PID"] = str(pid)
            return output
        
        # BFS fallback
        bfs_result = self.bfs_find_target(self.start_pid, self.targets)
        if bfs_result:
            pid, path, cmd = bfs_result
            evidence = self.format_evidence(pid, path, cmd)
            output.extend(evidence)
            # Update game state
            game_state.tokens["PID"] = str(pid)
            return output
        else:
            output.append("No malicious process found.")
            return output

